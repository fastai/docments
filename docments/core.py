# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['param_locs', 'docments']

# Cell
from tokenize import tokenize,COMMENT
from ast import parse,FunctionDef
from io import BytesIO
from textwrap import dedent
from fastcore.basics import *
import inspect,re

# Cell
def _parses(s):
    "Parse Python code in string or function object `s`"
    if inspect.isfunction(s): s = inspect.getsource(s)
    return parse(s)

# Cell
def param_locs(s):
    "`dict` of parameter line numbers to names"
    body = _parses(s).body
    assert len(body)==1,"Body must contain exactly one definition"
    assert isinstance(body[0], FunctionDef),"Body must contain a function definition"
    defn = body[0]
    return {defn.returns.lineno:'return', **{arg.lineno:arg.arg for arg in defn.args.args}}

# Cell
def _tokens(s):
    "Tokenize Python code in string or function object `s`"
    if inspect.isfunction(s): s = inspect.getsource(s)
    return tokenize(BytesIO(s.encode('utf-8')).readline)

_clean_re = re.compile('^\s*#(.*)\s*$')
def _clean_comment(s):
    res = _clean_re.findall(s)
    return res[0] if res else None

def _get_comment(line, arg, comments, parms):
    if line in comments: return comments[line].strip()
    line -= 1
    res = []
    while line and line in comments and line not in parms:
        res.append(comments[line])
        line -= 1
    return dedent('\n'.join(reversed(res))) if res else None

# Cell
def docments(s):
    "`dict` of parameter names to 'docment-style' comments in function or string `s`"
    comments = {o.start[0]:_clean_comment(o.string) for o in _tokens(s) if o.type==COMMENT}
    parms = param_locs(s)
    return {arg:_get_comment(line, arg, comments, parms) for line,arg in parms.items()}